# Clear the console
cat("\014")
# Remove every object in the environment
rm(list = ls())
#install and load packages
lib <- c("dplyr", "ggplot2", "gridExtra", "reshape2", "scales", "tidyr")
sapply(lib, function(x) require(x, character.only = TRUE))
ifelse(usage == 'One-to-One', 1, ifelse(usage == 'Moderate'), 0.7, 1.33)
felse(usage == 'One-to-One', 1, ifelse(usage == 'Moderate'), 0.7,
ifelse(usage == 'Media-Rich', 1.33, 'Error')
ifelse(usage == 'One-to-One', 1, ifelse(usage == 'Moderate', 0.7,
ifelse(usage == 'Media-Rich', 1.33, 'Error'))
ifelse(usage == 'One-to-One', 1, ifelse(usage == 'Moderate', 0.7,
ifelse(usage == 'Media-Rich', 1.33, 'Error')))
usage <- 'hmm'
# adjust usage based on bandwidth needs
ifelse(usage == 'One-to-One', 1, ifelse(usage == 'Moderate', 0.7,
ifelse(usage == 'Media-Rich', 1.33, 'Error')))
ifelse(usage == 'One-to-One', 1, ifelse(usage == 'Moderate', 0.7,
ifelse(usage == 'Media-Rich', 1.33, 'Error')))
usage <- 'Moderate'
# adjust usage based on bandwidth needs
ifelse(usage == 'One-to-One', 1, ifelse(usage == 'Moderate', 0.7,
ifelse(usage == 'Media-Rich', 1.33, 'Error')))
locale <- 'Rural'
avg_cost_per_mile <- ifelse(locale == 'Rural', 52000,
ifelse(locale == 'Small Town', 68500,
ifelse(locale %in% c('Suburban', 'Urban'), 88500, 'Error')))
ifelse(locale == 'Rural', 52000,
ifelse(locale == 'Small Town', 68500,
ifelse(locale %in% c('Suburban', 'Urban'), 88500, 'Error')))
ifelse(locale == 'Rural', 12,
ifelse(locale == 'Small Town', 6,
ifelse(locale %in% c('Suburban', 'Urban'), 1, 'Error')))
ifelse(district_size == 'Tiny', 1,
ifelse(district_size == 'Small', 1,
ifelse(district_size == 'Medium', 1.5,
ifelse(district_size == 'Large', 2,
ifelse(district_size == 'Mega', 2.75, 'Error')))))
ifelse(district_size == 'Tiny', 1,
ifelse(district_size == 'Small', 1,
ifelse(district_size == 'Medium', 1.5,
ifelse(district_size == 'Large', 2,
ifelse(district_size == 'Mega', 2.75, 'Error')))))
district_size <- 'Tiny'
ifelse(district_size == 'Tiny', 1,
ifelse(district_size == 'Small', 1,
ifelse(district_size == 'Medium', 1.5,
ifelse(district_size == 'Large', 2,
ifelse(district_size == 'Mega', 2.75, 'Error')))))
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
#sapply(lib, function(x) install.packages(x))
sapply(lib, function(x) library(x))
sapply(lib, function(x) library(x, character.only = TRUE))
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
#sapply(lib, function(x) install.packages(x))
sapply(lib, function(x) require(x, character.only = TRUE))
install.packages('shinyBS')
install.packages('ggvis')
sapply(lib, function(x) require(x, character.only = TRUE))
wd <- "~/Google Drive/github/ficher/Shiny"
setwd(wd)
services <- read.csv("sr_030816.csv")
print(nrow(services)) #83203
services_all <- read.csv("sr_030816.csv")
services_mode <- read.csv("sr_030816.csv")
services <- services_mode %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
print(nrow(services)) #15844
print(length(unique(services$line_item_id))) #13586
services$open_flags
services[!grepl("exclude_for_cost_only", services$open_flags),]
grepl("exclude_for_cost_only", services$open_flags)
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
nrow(services) #now, there are 12,966 line items
length(unique(services$line_item_id))
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
#sapply(lib, function(x) install.packages(x))
sapply(lib, function(x) require(x, character.only = TRUE))
services_mode <- read.csv("sr_030816.csv")
ddt <- read.csv("ddt_030816.csv")
# print(nrow(services_mode)) #83203
print(nrow(ddt)) #13025
### SERVICES RECEIVED
# filter the data, using proper conditions
services <- services_mode %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
# nrow(services) #15844
length(unique(services$line_item_id)) #13586
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
nrow(services)
services_mode <- read.csv("sr_030816.csv", as.is = TRUE)
services$ia_bandwidth_per_student <- as.numeric(li$ia_bandwidth_per_student)
services$ia_bandwidth_per_student <- as.numeric(services$ia_bandwidth_per_student)
services$band_factor <- as.factor(services$bandwidth_in_mbps)
class(services$postal_cd)
services_mode <- read.csv("sr_030816.csv", as.is = TRUE)
class(services$postal_cd)
services <- services_mode %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
services$postal_cd <- as.character(services$postal_cd)
services$new_purpose[services$internet_conditions_met == TRUE] <- "Internet"
services$new_purpose[services$wan_conditions_met == TRUE] <- "WAN"
services$new_purpose[services$isp_conditions_met == TRUE] <- "ISP Only"
services$new_purpose[services$upstream_conditions_met == TRUE] <- "Upstream"
table(services$new_purpose)
districts_mode <- read.csv("ddt_030816.csv", as.is = TRUE)
print(nrow(districts_mode)) #13025
districts$ia_bandwidth_per_student <- as.numeric(districts$ia_bandwidth_per_student)
districts <- read.csv("ddt_030816.csv", as.is = TRUE)
districts$ia_bandwidth_per_student <- as.numeric(districts$ia_bandwidth_per_student)
districts$exclude <- ifelse(districts$exclude_from_analysis == "FALSE", "Clean", "Dirty")
districts$meeting_2014_goal_no_oversub <- ifelse(districts$meeting_2014_goal_no_oversub == "TRUE",
"Meeting 2014 Goals",
"Not Meeting 2014 Goals")
districts$meeting_2018_goal_oversub <- ifelse(districts$meeting_2018_goal_oversub == "TRUE",
"Meeting 2018 Goals",
"Not Meeting 2018 Goals")
districts$meeting_2018_goal_oversub <- as.factor(districts$meeting_2018_goal_oversub)
districts$meeting_2014_goal_no_oversub <- as.factor(districts$meeting_2014_goal_no_oversub)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
switch(1, invisible(pi), pi)
switch(2, invisible(pi), pi)
switch(1,
"Line items for B-W" = li_bf,
"Line items for Comparisons" = li_all,
"Deluxe districts for Selected Districts" = district_subset_specific)
switch(1,
"Line items for B-W" = "li_bf",
"Line items for Comparisons" = li_all,
"Deluxe districts for Selected Districts" = district_subset_specific)
shiny::runApp()
wd <- "~/Google Drive/github/ficher/Shiny"
setwd(wd)
shinyServer(function(input, output, session) {
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
#sapply(lib, function(x) install.packages(x))
sapply(lib, function(x) require(x, character.only = TRUE))
services <- read.csv("services_received_20160404.csv", as.is = TRUE)
districts <- read.csv("deluxe_districts_20160404.csv", as.is = TRUE)
shiny::runApp()
shiny::runApp()
services[!duplicated(services$line_item_id), ]
shiny::runApp()
services <- services %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
services$ia_bandwidth_per_student <- as.numeric(services$ia_bandwidth_per_student)
services$postal_cd <- as.character(services$postal_cd)
services$band_factor <- as.factor(services$bandwidth_in_mbps)
services$new_purpose[services$internet_conditions_met == TRUE] <- "Internet"
services$new_purpose[services$wan_conditions_met == TRUE] <- "WAN"
services$new_purpose[services$isp_conditions_met == TRUE] <- "ISP Only"
services$new_purpose[services$upstream_conditions_met == TRUE] <- "Upstream"
services$monthly_cost_per_circuit <- services$line_item_total_monthly_cost / services$line_item_total_num_lines
services$monthly_cost_per_mbps <- services$monthly_cost_per_circuit / services$bandwidth_in_mbps
shiny::runApp()
services_b_w %>%
group_by(bandwidth_in_mbps) %>%
summarize(n = n())
services_b_w <- filter(services, services$bandwidth_in_mbps %in% c(50, 100, 500, 1000, 10000))
services_b_w %>%
group_by(bandwidth_in_mbps) %>%
summarize(n = n())
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
services
services %>%
group_by(band_factor) %>%
summarise(len = n())
ns <-
services %>%
group_by(band_factor) %>%
summarise(len = n())
head(ns)
whitespace_size <- 180 / (nrow(ns)^1.3)
whitespace <- paste(rep(" ", whitespace_size), collapse = "")
formatted <- sapply(ns[,2], function(x) paste(x,collapse = whitespace))
formatted
leadspace_size <- 100/(nrow(ns)^2.6)
leadspace <- paste(rep(" ", leadspace_size), collapse = "")
print(formatted)
leadspace
len
ns
tail(ns)
shiny::runApp()
shiny::runApp()
shiny::runApp()
head(ns)
sum(ns$len)
shiny::runApp()
shiny::runApp()
shiny::runApp()
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
#sapply(lib, function(x) install.packages(x))
sapply(lib, function(x) require(x, character.only = TRUE))
wd <- "~/Google Drive/github/ficher/Shiny"
setwd(wd)
services <- read.csv("services_received_20160404.csv", as.is = TRUE)
districts <- read.csv("deluxe_districts_20160404.csv", as.is = TRUE)
# nrow(services) #83203
# nrow(districts) #13025
### SERVICES RECEIVED
# filter the data, using proper conditions
services <- services %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
# nrow(services) #15844
# length(unique(services$line_item_id)) #13586
# exclude rows that that contain duplicate line items
services <- services[!duplicated(services$line_item_id), ]
# exclude rows that should be excluded for cost calculations
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
# nrow(services) #15,060
# Convert variables to relevant types
services$ia_bandwidth_per_student <- as.numeric(services$ia_bandwidth_per_student)
services$postal_cd <- as.character(services$postal_cd)
services$band_factor <- as.factor(services$bandwidth_in_mbps)
# Append new column for purpose type
services$new_purpose[services$internet_conditions_met == TRUE] <- "Internet"
services$new_purpose[services$wan_conditions_met == TRUE] <- "WAN"
services$new_purpose[services$isp_conditions_met == TRUE] <- "ISP Only"
services$new_purpose[services$upstream_conditions_met == TRUE] <- "Upstream"
# table(services$new_purpose)
# Appending new column for monthly cost per circuit:
services$monthly_cost_per_circuit <- services$line_item_total_monthly_cost / services$line_item_total_num_lines
services$monthly_cost_per_mbps <- services$monthly_cost_per_circuit / services$bandwidth_in_mbps
##  SERVICES RECEIVED DATA: END ##
### DELUXE DISTRICTS TABLE:  prepping the data to be the correct subset to use ###
districts$ia_bandwidth_per_student <- as.numeric(districts$ia_bandwidth_per_student)
# New Variables for mapping #
districts$exclude <- ifelse(districts$exclude_from_analysis == "FALSE", "Clean", "Dirty")
districts$meeting_2014_goal_no_oversub <- ifelse(districts$meeting_2014_goal_no_oversub == "TRUE",
"Meeting 2014 Goals",
"Not Meeting 2014 Goals")
districts$meeting_2018_goal_oversub <- ifelse(districts$meeting_2018_goal_oversub == "TRUE",
"Meeting 2018 Goals",
"Not Meeting 2018 Goals")
districts$meeting_2018_goal_oversub <- as.factor(districts$meeting_2018_goal_oversub)
districts$meeting_2014_goal_no_oversub <- as.factor(districts$meeting_2014_goal_no_oversub)
# export
write.csv(services, "services_received_shiny.csv", row.names = FALSE)
write.csv(districts, "districts_shiny.csv", row.names = FALSE)
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
sapply(lib, function(x) require(x, character.only = TRUE))
wd <- "~/Google Drive/github/ficher/Shiny"
setwd(wd)
services <- read.csv("services_shiny.csv", as.is = TRUE)
districts <- read.csv("districts_shiny.csv", as.is = TRUE)
services <- read.csv("services_received_shiny.csv", as.is = TRUE)
nrow(services) #83203
nrow(services)
nrow(districts)
services <- read.csv("services_received_20160404.csv", as.is = TRUE)
nrow(services) #83203
nrow(districts) #13025
services <- services %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
nrow(services) #15844
length(unique(services$line_item_id)) #13586
services <- services[!duplicated(services$line_item_id), ]
nrow(services)
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
nrow(services) #15,060
services$ia_bandwidth_per_student <- as.numeric(services$ia_bandwidth_per_student)
services$postal_cd <- as.character(services$postal_cd)
services$band_factor <- as.factor(services$bandwidth_in_mbps)
services$new_purpose[services$internet_conditions_met == TRUE] <- "Internet"
services$new_purpose[services$wan_conditions_met == TRUE] <- "WAN"
services$new_purpose[services$isp_conditions_met == TRUE] <- "ISP Only"
services$new_purpose[services$upstream_conditions_met == TRUE] <- "Upstream"
services$monthly_cost_per_circuit <- services$line_item_total_monthly_cost / services$line_item_total_num_lines
services$monthly_cost_per_mbps <- services$monthly_cost_per_circuit / services$bandwidth_in_mbps
### DELUXE DISTRICTS TABLE:  prepping the data to be the correct subset to use ###
districts$ia_bandwidth_per_student <- as.numeric(districts$ia_bandwidth_per_student)
districts$exclude <- ifelse(districts$exclude_from_analysis == "FALSE", "Clean", "Dirty")
districts$meeting_2014_goal_no_oversub <- ifelse(districts$meeting_2014_goal_no_oversub == "TRUE",
"Meeting 2014 Goals",
"Not Meeting 2014 Goals")
districts$meeting_2018_goal_oversub <- ifelse(districts$meeting_2018_goal_oversub == "TRUE",
"Meeting 2018 Goals",
"Not Meeting 2018 Goals")
districts$meeting_2018_goal_oversub <- as.factor(districts$meeting_2018_goal_oversub)
districts$meeting_2014_goal_no_oversub <- as.factor(districts$meeting_2014_goal_no_oversub)
# export
write.csv(services, "services_received_shiny.csv", row.names = FALSE)
write.csv(districts, "districts_shiny.csv", row.names = FALSE)
# Clear the console
cat("\014")
# Remove every object in the environment
rm(list = ls())
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
#sapply(lib, function(x) install.packages(x))
sapply(lib, function(x) require(x, character.only = TRUE))
wd <- "~/Google Drive/github/ficher/Shiny"
setwd(wd)
services <- read.csv("services_received_20160404.csv", as.is = TRUE)
districts <- read.csv("deluxe_districts_20160404.csv", as.is = TRUE)
# nrow(services) #83196
# nrow(districts) #13025
### SERVICES RECEIVED
# filter the data, using proper conditions
services <- services %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
# nrow(services) #15812
# length(unique(services$line_item_id)) #13,554
# exclude rows that that contain duplicate line items
services <- services[!duplicated(services$line_item_id), ]
# nrow(services)
# exclude rows that should be excluded for cost calculations
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
# nrow(services) #12,939
# Convert variables to relevant types
services$ia_bandwidth_per_student <- as.numeric(services$ia_bandwidth_per_student)
services$postal_cd <- as.character(services$postal_cd)
services$band_factor <- as.factor(services$bandwidth_in_mbps)
# Append new column for purpose type
services$new_purpose[services$internet_conditions_met == TRUE] <- "Internet"
services$new_purpose[services$wan_conditions_met == TRUE] <- "WAN"
services$new_purpose[services$isp_conditions_met == TRUE] <- "ISP Only"
services$new_purpose[services$upstream_conditions_met == TRUE] <- "Upstream"
# table(services$new_purpose)
# Appending new column for monthly cost per circuit:
services$monthly_cost_per_circuit <- services$line_item_total_monthly_cost / services$line_item_total_num_lines
services$monthly_cost_per_mbps <- services$monthly_cost_per_circuit / services$bandwidth_in_mbps
##  SERVICES RECEIVED DATA: END ##
### DELUXE DISTRICTS TABLE:  prepping the data to be the correct subset to use ###
districts$ia_bandwidth_per_student <- as.numeric(districts$ia_bandwidth_per_student)
# New Variables for mapping #
districts$exclude <- ifelse(districts$exclude_from_analysis == "FALSE", "Clean", "Dirty")
districts$meeting_2014_goal_no_oversub <- ifelse(districts$meeting_2014_goal_no_oversub == "TRUE",
"Meeting 2014 Goals",
"Not Meeting 2014 Goals")
districts$meeting_2018_goal_oversub <- ifelse(districts$meeting_2018_goal_oversub == "TRUE",
"Meeting 2018 Goals",
"Not Meeting 2018 Goals")
districts$meeting_2018_goal_oversub <- as.factor(districts$meeting_2018_goal_oversub)
districts$meeting_2014_goal_no_oversub <- as.factor(districts$meeting_2014_goal_no_oversub)
# export
write.csv(services, "services_received_shiny.csv", row.names = FALSE)
write.csv(districts, "districts_shiny.csv", row.names = FALSE)
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
sapply(lib, function(x) require(x, character.only = TRUE))
wd <- "~/Google Drive/github/ficher/Shiny"
setwd(wd)
services <- read.csv("services_received_shiny.csv", as.is = TRUE)
districts <- read.csv("districts_shiny.csv", as.is = TRUE)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
districts$not_all_scalable <- ifelse(districts$nga_v2_known_unscalable_campuses + districts$nga_v2_assumed_unscalable_campuses > 0, 1, 0)
districts %>%
filter(not_all_scalable == 1)
test <- districts %>%
filter(not_all_scalable == 1)
shiny::runApp()
# Clear the console
cat("\014")
# Remove every object in the environment
rm(list = ls())
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
#sapply(lib, function(x) install.packages(x))
sapply(lib, function(x) require(x, character.only = TRUE))
wd <- "~/Google Drive/github/ficher/Shiny"
setwd(wd)
services <- read.csv("services_received_20160404.csv", as.is = TRUE)
districts <- read.csv("deluxe_districts_20160404.csv", as.is = TRUE)
# nrow(services) #83196
# nrow(districts) #13025
### SERVICES RECEIVED
# filter the data, using proper conditions
services <- services %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
# nrow(services) #15812
# length(unique(services$line_item_id)) #13,554
# exclude rows that that contain duplicate line items
services <- services[!duplicated(services$line_item_id), ]
# nrow(services)
# exclude rows that should be excluded for cost calculations
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
# nrow(services) #12,939
# Convert variables to relevant types
services$ia_bandwidth_per_student <- as.numeric(services$ia_bandwidth_per_student)
services$postal_cd <- as.character(services$postal_cd)
services$band_factor <- as.factor(services$bandwidth_in_mbps)
# Append new column for purpose type
services$new_purpose[services$internet_conditions_met == TRUE] <- "Internet"
services$new_purpose[services$wan_conditions_met == TRUE] <- "WAN"
services$new_purpose[services$isp_conditions_met == TRUE] <- "ISP Only"
services$new_purpose[services$upstream_conditions_met == TRUE] <- "Upstream"
# table(services$new_purpose)
# Appending new column for monthly cost per circuit:
services$monthly_cost_per_circuit <- services$line_item_total_monthly_cost / services$line_item_total_num_lines
services$monthly_cost_per_mbps <- services$monthly_cost_per_circuit / services$bandwidth_in_mbps
##  SERVICES RECEIVED DATA: END ##
### DELUXE DISTRICTS TABLE:  prepping the data to be the correct subset to use ###
districts$ia_bandwidth_per_student <- as.numeric(districts$ia_bandwidth_per_student)
# New Variables for mapping #
districts$exclude <- ifelse(districts$exclude_from_analysis == "FALSE", "Clean", "Dirty")
districts$meeting_2014_goal_no_oversub <- ifelse(districts$meeting_2014_goal_no_oversub == "TRUE",
"Meeting 2014 Goals",
"Not Meeting 2014 Goals")
districts$meeting_2018_goal_oversub <- ifelse(districts$meeting_2018_goal_oversub == "TRUE",
"Meeting 2018 Goals",
"Not Meeting 2018 Goals")
districts$meeting_2018_goal_oversub <- as.factor(districts$meeting_2018_goal_oversub)
districts$meeting_2014_goal_no_oversub <- as.factor(districts$meeting_2014_goal_no_oversub)
# create indicator for district having at least 1 unscalable campus
districts$not_all_scalable <- ifelse(districts$nga_v2_known_unscalable_campuses + districts$nga_v2_assumed_unscalable_campuses > 0, 1, 0)
# export
write.csv(services, "services_received_shiny.csv", row.names = FALSE)
write.csv(districts, "districts_shiny.csv", row.names = FALSE)
shiny::runApp()
shiny::runApp()
# Clear the console
cat("\014")
# Remove every object in the environment
rm(list = ls())
lib <- c("dplyr", "shiny", "shinyBS", "tidyr", "ggplot2", "scales", "grid", "maps", "ggmap", "ggvis")
#sapply(lib, function(x) install.packages(x))
sapply(lib, function(x) require(x, character.only = TRUE))
wd <- "~/Google Drive/github/ficher/Shiny/prep_for_Shiny"
setwd(wd)
services <- read.csv("services_received_20160404.csv", as.is = TRUE)
districts <- read.csv("deluxe_districts_20160404.csv", as.is = TRUE)
# nrow(services) #83196
# nrow(districts) #13025
### SERVICES RECEIVED
# filter the data, using proper conditions
services <- services %>%
filter(shared_service == "District-dedicated" &
dirty_status == "include clean" & exclude == "FALSE")
# nrow(services) #15812
# length(unique(services$line_item_id)) #13,554
# exclude rows that that contain duplicate line items
services <- services[!duplicated(services$line_item_id), ]
# nrow(services)
# exclude rows that should be excluded for cost calculations
services <- services[!grepl("exclude_for_cost_only", services$open_flags),]
# nrow(services) #12,939
# Convert variables to relevant types
services$ia_bandwidth_per_student <- as.numeric(services$ia_bandwidth_per_student)
services$postal_cd <- as.character(services$postal_cd)
services$band_factor <- as.factor(services$bandwidth_in_mbps)
# Append new column for purpose type
services$new_purpose[services$internet_conditions_met == TRUE] <- "Internet"
services$new_purpose[services$wan_conditions_met == TRUE] <- "WAN"
services$new_purpose[services$isp_conditions_met == TRUE] <- "ISP Only"
services$new_purpose[services$upstream_conditions_met == TRUE] <- "Upstream"
# table(services$new_purpose)
# Appending new column for monthly cost per circuit:
services$monthly_cost_per_circuit <- services$line_item_total_monthly_cost / services$line_item_total_num_lines
services$monthly_cost_per_mbps <- services$monthly_cost_per_circuit / services$bandwidth_in_mbps
##  SERVICES RECEIVED DATA: END ##
### DELUXE DISTRICTS TABLE:  prepping the data to be the correct subset to use ###
districts$ia_bandwidth_per_student <- as.numeric(districts$ia_bandwidth_per_student)
# New Variables for mapping #
districts$exclude <- ifelse(districts$exclude_from_analysis == "FALSE", "Clean", "Dirty")
districts$meeting_2014_goal_no_oversub <- ifelse(districts$meeting_2014_goal_no_oversub == "TRUE",
"Meeting 2014 Goals",
"Not Meeting 2014 Goals")
districts$meeting_2018_goal_oversub <- ifelse(districts$meeting_2018_goal_oversub == "TRUE",
"Meeting 2018 Goals",
"Not Meeting 2018 Goals")
districts$meeting_2018_goal_oversub <- as.factor(districts$meeting_2018_goal_oversub)
districts$meeting_2014_goal_no_oversub <- as.factor(districts$meeting_2014_goal_no_oversub)
# create indicator for district having at least 1 unscalable campus
districts$not_all_scalable <- ifelse(districts$nga_v2_known_unscalable_campuses + districts$nga_v2_assumed_unscalable_campuses > 0, 1, 0)
wd <- "~/Google Drive/github/ficher/Shiny"
setwd(wd)
# export
write.csv(services, "services_received_shiny.csv", row.names = FALSE)
write.csv(districts, "districts_shiny.csv", row.names = FALSE)
